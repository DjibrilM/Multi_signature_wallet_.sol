{
  "language": "Solidity",
  "sources": {
    "contracts/MultisignatureWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\n//Errors\nerror InvalidApprovalCount();\nerror ExceedSignersCount();\nerror MiliciousInitiator();\nerror NoEnoughMoneyInWallet();\n\ncontract MultiSignatureWallet {\n    //STRUCTSðŸ‘‡\n    /**\n     * @dev This struct describes a pending transaction within a given wallet,\n     *  and one wallet can have many pending transactions\n     * @param repcipient The recipient of the transaction;\n     * @param from The address that initiated the transaction\n     * @param amount The transaction amount\n     * @param approvalCount the number of validations that have been declared\n     * @param param The previous signers parameter keep track of all the people\n     *              Who have contributed to the signing process, this prevent\n     *              single signing loop, which consists of one signer having to\n     *              sign for all the others .\n     */\n    struct PendingTransaction {\n        address recipient;\n        address from;\n        uint256 amount;\n        uint256 approvalCount;\n        address[] previousSigners;\n    }\n\n    /**\n     * @dev Signers are people that can validate a transaction.\n     *       Signers within a wallet don't hold the same permission some can initiate\n     *       transactions and other can't.\n     * @param canInitiateTransaction This indicates the whether this singer can initiate a transaction or not.\n     */\n    struct Signer {\n        address singerAddress;\n        bool canInitiateTransaction;\n    }\n\n    /**\n     * @dev This struct describes all the available parameters of a wallet.\n     * @param amount The total amount of funds in the wallet.\n     * @param the The locked parameter is used to lock the wallet when a withdraw\n     *            is initiated, this prevents things like Reentrancy Attack\n     * @param signers The list of validators allowed to sign transactions.\n     * @param pendingTransaction A list of transaction IDs that haven't been validated yet.\n     *        A wallet can have multiple pending transactions\n     */\n    struct Wallet {\n        uint256 balance;\n        Signer[] signers;\n        PendingTransaction[] pendingTransactions;\n        uint16 approvalCount;\n        bool locked;\n    }\n\n    //STATE VARIABLES AND MAPPINGSðŸ‘‡\n    address public immutable i_owner;\n    uint256 public immutable i_maximum_pendingTransaction;\n    uint256 public immutable i_maximum_signers;\n\n    mapping(address => Wallet) internal s_wallets;\n\n    //EVENTSðŸ‘‡\n\n    //Event fired when a transaction is initiated\n    event PendingTransactionInitiation(\n        address indexed recipient,\n        address indexed walletAddress,\n        uint256 amount\n    );\n    //Fired when pending counts reached and when the funds are sent to the recipient;\n    event PendingTransactionClose(\n        address indexed recipient,\n        address indexed walletAddress,\n        address finalValidator,\n        uint256 amount,\n        uint256 approvalCount\n    );\n\n    //MODIFIERS\n    modifier WalletAlreadyCreated(address walletAddress) {\n        require(\n            s_wallets[walletAddress].signers.length > 1,\n            \"Wallet already created\"\n        );\n        _;\n    }\n    /**\n     * @dev Check if the wallet exists\n     * @param walletAddress  Wallet address\n     */\n    modifier WalletDoesNotExist(address walletAddress) {\n        require(\n            s_wallets[walletAddress].signers.length < 1,\n            \"Wllet does not exist\"\n        );\n        _;\n    }\n\n    modifier NoReentrancy(address _walletAddress) {\n        require(!s_wallets[_walletAddress].locked, \"No re-entrency\");\n        s_wallets[_walletAddress].locked = true;\n        _;\n        s_wallets[_walletAddress].locked = false;\n    }\n\n    /**\n     * @dev The bellow modifier checkes the the initiror is legit and if they can initiate a transaction\n     * @param _signers  List of signers withing the given wallet\n     * @param _inititor The transaction initiator\n     */\n    modifier CanInitiateTransaction(\n        Signer[] memory _signers,\n        address _inititor\n    ) {\n        Signer memory signer;\n        for (uint i = 0; i < _signers.length; i++) {\n            if (_signers[i].singerAddress == _inititor) {\n                signer = _signers[i];\n            }\n        }\n        if (!signer.canInitiateTransaction) {\n            revert MiliciousInitiator();\n        }\n        _;\n    }\n\n    modifier IsValidSigner(address _walletAddress, address _signer) {\n        bool isSigner;\n        uint256 signersLength = s_wallets[_walletAddress].signers.length;\n        for (uint i = 0; i < signersLength; i++) {\n            if (s_wallets[_walletAddress].signers[i].singerAddress == _signer) {\n                isSigner = true;\n            }\n        }\n\n        require(isSigner, \"Invalid signer\");\n        _;\n    }\n\n    //Constructor\n    constructor(\n        address _owner,\n        uint256 _maximum_pendingTransaction,\n        uint256 _maximum_signers\n    ) {\n        i_owner = _owner;\n        i_maximum_pendingTransaction = _maximum_pendingTransaction;\n        i_maximum_signers = _maximum_signers;\n    }\n\n    /**\n     * The receive function will send back the fund to the send if they don't have a wallet yet\n     */\n    receive() external payable {\n        require(\n            s_wallets[msg.sender].signers.length < 1,\n            \"Don't have a wallet yet\"\n        );\n\n        //Increament the balance of the sender\n        s_wallets[msg.sender].balance += msg.value;\n    }\n\n    /**\n     * The given function update the approval count of a pending transaction, and send\n     * the funds if the count has reach the maximum number of approvals need to sign and\n     * send send the funds.\n     * @param _walletAddress Sender's wallet address.\n     * @param _transactionIndex The transaction's index based on the given wallet.\n     */\n    function updateApprovalCount(\n        address _walletAddress,\n        uint256 _transactionIndex\n    )\n        external\n        payable\n        NoReentrancy(_walletAddress)\n        IsValidSigner(_walletAddress, msg.sender)\n        returns (bool suc)\n    {\n        PreventDoubleSigning(_walletAddress, _transactionIndex, msg.sender);\n        PendingTransaction memory transaction = s_wallets[_walletAddress]\n            .pendingTransactions[_transactionIndex];\n\n        s_wallets[_walletAddress]\n            .pendingTransactions[_transactionIndex]\n            .approvalCount += 1;\n\n        s_wallets[_walletAddress]\n            .pendingTransactions[_transactionIndex]\n            .previousSigners\n            .push(msg.sender);\n\n        if (\n            s_wallets[_walletAddress]\n                .pendingTransactions[_transactionIndex]\n                .approvalCount >= s_wallets[_walletAddress].approvalCount\n        ) {\n            address payable recipient = payable(\n                s_wallets[_walletAddress]\n                    .pendingTransactions[_transactionIndex]\n                    .recipient\n            );\n\n            uint256 amount = s_wallets[_walletAddress]\n                .pendingTransactions[_transactionIndex]\n                .amount;\n\n            (bool succ, ) = recipient.call{value: amount}(\"\");\n\n            require(succ, \"Failed to transfer funds\");\n\n            s_wallets[_walletAddress].balance -= amount;\n\n            //Delete the pending transaction from pending transactions list\n            uint256 pendingTransactionsLength = s_wallets[_walletAddress]\n                .pendingTransactions\n                .length;\n\n            if (pendingTransactionsLength == 1) {\n                s_wallets[_walletAddress].pendingTransactions.pop();\n\n                return true;\n            }\n\n            //Array Remove An Element By Shifting.\n            // Resource about the implementation => https://www.youtube.com/watch?v=szv2zJcy_Xs&t=140s\n            for (\n                uint index = _transactionIndex;\n                index < pendingTransactionsLength - 1;\n                index++\n            ) {\n                s_wallets[_walletAddress].pendingTransactions[\n                    index\n                ] = s_wallets[_walletAddress].pendingTransactions[index + 1];\n            }\n\n            //Remove the last duplicate\n            s_wallets[_walletAddress].pendingTransactions.pop();\n\n            //Signal the end of the pending transaction\n            emit PendingTransactionClose(\n                transaction.recipient,\n                _walletAddress,\n                msg.sender,\n                transaction.amount,\n                transaction.approvalCount\n            );\n        }\n\n        return true;\n    }\n\n    function getWallet(\n        address walletAddress\n    ) public view returns (Wallet memory) {\n        return s_wallets[walletAddress];\n    }\n\n    function getAmout(address walletAddress) public view returns (uint256) {\n        return s_wallets[walletAddress].balance;\n    }\n\n    /**\n     * @dev  The bellow function is in charge of creating a wallet\n     * @param _owner Owner of the wallet or master user\n     * @param _signers All the memembers that can approve a transaction\n     * @param _approvalCount The total number of approval that can initiate a transaction\n     */\n    function createWallet(\n        address _owner,\n        Signer[] memory _signers,\n        uint16 _approvalCount\n    ) public WalletAlreadyCreated(_owner) {\n        //Check if the approval counts is greater than the signers or if\n        // singners are greater that the maximum singners limit.\n        if (_approvalCount > _signers.length) {\n            revert InvalidApprovalCount();\n        } else if (_signers.length > i_maximum_signers) {\n            revert ExceedSignersCount();\n        }\n\n        uint256 signersLength = _signers.length;\n\n        s_wallets[_owner].balance = 0;\n        s_wallets[_owner].approvalCount = _approvalCount;\n\n        for (uint i = 0; i < signersLength; i++) {\n            Signer memory newSigner = Signer(\n                _signers[i].singerAddress,\n                _signers[i].canInitiateTransaction\n            );\n            s_wallets[_owner].signers.push(newSigner);\n        }\n\n        //Wallet owner must also be a signer\n        s_wallets[_owner].signers.push(Signer(i_owner, true));\n    }\n\n    /**\n     * @param _initiator Initiator of the transaction.\n     * @param _walletAddrss The given wallet address.\n     * @param _amount The amount of money to be sent.\n     * @param _recipient the recipient address.\n     */\n    function initiateTransaction(\n        address _initiator,\n        address _walletAddrss,\n        uint256 _amount,\n        address _recipient\n    )\n        public\n        CanInitiateTransaction(s_wallets[_walletAddrss].signers, _initiator)\n        WalletDoesNotExist(_walletAddrss)\n        returns (bool)\n    {\n        if (_amount > s_wallets[_walletAddrss].balance) {\n            revert NoEnoughMoneyInWallet();\n        }\n\n        PendingTransaction memory newPendingTransaction = PendingTransaction({\n            amount: _amount,\n            recipient: _recipient,\n            from: _initiator,\n            approvalCount: 0,\n            previousSigners: new address[](0)\n        });\n\n        s_wallets[_walletAddrss].pendingTransactions.push(\n            newPendingTransaction\n        );\n\n        emit PendingTransactionInitiation(_recipient, _walletAddrss, _amount);\n        return true;\n    }\n\n    function PreventDoubleSigning(\n        address _wallet_address,\n        uint256 _transactionIndex,\n        address _signer\n    ) internal view {\n        address[] memory signers = s_wallets[_wallet_address]\n            .pendingTransactions[_transactionIndex]\n            .previousSigners;\n\n        for (uint i = 0; i < signers.length; i++) {\n            require(signers[i] != _signer, \"Double signing not allowed\");\n        }\n    }\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}